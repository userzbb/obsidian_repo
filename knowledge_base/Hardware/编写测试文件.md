---
created: 2025-12-25T23:18:13+08:00
modified: 2025-12-26T00:33:32+08:00
---

###  Testbench 基本结构
Testbench 由**不可综合**的 Verilog 代码组成，这些代码用于生成待测模块的输入，并验证待测模块的输出是否正确（是否符合预期）。下图展示了一个 Testbench 的基本架构。
![[Pasted image 20251225232326.png]]
其中：
- 激励（Stimulus Block）是专门为待测模块生成的输入。我们需要尽可能产生全面的测试场景，包括合法的和不合法的。
- 输出校验（Output Checker）用于检查被测模块的输出是否符合预期。
- 被测模块（Design Under Test, DUT。也称 Unit Under Test, UUT）是我们编写的 Verilog 模块，Testbench 的主要目的就是对其进行验证，以确保在特定输入下其输出均与预期一致。
```verilog
/*
编写 Testbench 的第一步是创建一个 Verilog 模块作为测试的顶层模块。与正常设计时的 Verilog module 不同，用于测试的模块应当**没有输入和输出**，这是因为 Testbench 模块应当是完全独立的，不受外部信号的干扰。
*/

/*
接下来，我们需要例化待测模块，将信号连接到待测模块以允许激励代码运行。这些信号包括时钟信号和复位信号，以及传入 Testbench 的测试数据。下面的代码片段展示了一个 Testbench 的基本框架。
*/
module Module_tb ();

// 定义并产生激励信号
// ......

Test_module #(
    // 参数接口
) test (
    // 待测模块端口
);
endmodule
```

### 时序控制
与我们正常的设计代码不同，Testbench 中的代码并不需要被综合成实际电路，为此可以使用一些不可综合的语句，例如时序控制语句。
```verilog
/*
Verilog 中允许我们模拟两种不同的延时：惯性延时和传输延时。惯性延迟是逻辑门或电路由于其物理特性而可能经历的延迟，而传输延迟是电路中信号的『飞行』时间。

Verilog 使用 `#` 字符加上时间单位来模拟延时。例如 `#10;` 表示延迟 10 个时间单位后再执行之后的语句，对应着传输延迟。惯性延迟将延时语句写在与赋值相同的代码行中，这代表信号在延迟时间之后开始变化。例如：
*/

/*
A 或 B 任意一个变量发生变化，都会让 Z 在 10 个时间单位的延迟后得到新的值。如果在这 10 个时间单位内，A 或 B 中的任意一个又发生了变化，那么最终 Z 的新值会取 A 或 B 当前的新值。
*/
wire Z, A, B;
assign #10 Z = A & B;
// A&B 的计算结果延时 10 个时间单位赋值给 Z

/*
我们用一个具体的例子向大家阐述惯性延时的概念。考虑下面这条语句（假定时间单位为 ns）：
*/
assign #2 z = ~a;

/*
这条语句描述了一个延迟为 2ns 的非门，从输入端输入到输出端输出结果之间间隔了 2ns，且任何小于 2ns 的信号脉冲都会被滤除。后面那句话怎么理解呢？考虑如下的仿真语句：
*/
module test_tb ();
wire z;
reg a;
assign #2 z = ~a;

initial begin
    a = 1'b0;
    #3;
    a = 1'b1;
    #4;
    a = 1'b0;
    #1;
    a = 1'b1;
end
endmodule

```
```verilog
//为了明确在仿真期间所使用的时间单位，我们需要使用 `` `timescale `` 指令。其格式为：
`timescale <unit_time> / <resolution>

//其中， <unit_time> 指定时间的单位，<resolution> 指定时间的精度，例如我们常常使用的
`timescale 1ns / 1ps

//代表仿真的一个时间单位是 1ns，最小时间精度为 1ps。如果使用了 `#1.1111;` 指令，则最终的延迟为 1.111ns（四舍五入）

```
除了直接控制延迟，Verilog 还支持基于事件的时间控制，这就是 `@` 符号的作用。Verilog 有以下三种常用的事件控制方式：
1. `@` + 信号名，表示当信号发生逻辑变化时执行后面的内容。例如 `@ (in) out = in;`
2. `@` + `posedge` + 信号名，表示当信号从低电平变化到高电平时执行后面的内容。例如 `@ (podedge in) out = in;`
3. `@` + `negedge` + 信号名，表示当信号从高电平变化到低电平时执行后面的内容。例如 `@ (negedge in) out = in;`
这也印证了 always 语句的敏感变量语法。

### initial 与 always
在 Lab1 中我们介绍过，initial 块中编写的任何代码都会在开始时执行，但仅执行一次，而 always 块则会循环执行内部的代码。与 always 块不同，在 initial 块中编写的 Verilog 代码几乎都是不可综合的，因此基本上只被用于仿真与初始化信号。
> [!question]- 思考：为什么initial块中的代码不可综合
> 这里综合的含义是指能生成对应的硬件电路。
> 
> always会根据时钟条件无限次触发，所以always里面语句就像硬件电路，来一个时钟，执行一次。
> 
> 而initial就像是初始化程序，最开始把变量初始化，执行一次后不能再执行，直到再次复位。
> 
> （你总不能设计一个用了一次就消失不见的电路元件吧）

> [!example]+ 两输入与门的测试
> 假定我们想要测试下面的 Verilog 代码：
> ```verilog title=1b_AND
> module MyAND (
>     input               a, b,
>     output              o
> );
> assign o = a & b;
> endmodule
> ```
> 位宽为 1 的两输入与门一共只有 \(2^2=4\) 种可能的输入，因此我们可以直接枚举所有可能的情况。此外，我们还需要使用延时运算符在不同的输入之间增加一段延迟，便于我们观察到结果的变化。
